%%scalene --reduced-profile

### Block to define the rate of momentum loss, computed in CGS base units ###
# Klein-Nishina factor from Evoli et al. arXiv:2007.01302 (2020) #


ISRF_components = ['CMB', 'IR', 'OPT', 'UV_1', 'UV_2', 'UV_3']
T_ISRF = [2.725, 33.07, 313.32, 3249.3, 6150.4, 23209.0]            # in [K]
U_ISRF = [0.26e-9, 0.25e-9, 0.055e-9, 0.37e-9, 0.23e-9, 0.12e-9]    # energy density of the contributions, in [GeV cm^(-3)]

sigma_Thomson = 6.65e-25                             # in [cm^2]
c_cm = 2.99e+10                                      # speed of light, in [cm s^(-1)]
factor_ratio = ( 45 / (64*np.pi**2) )


# Leptons
def loss_rate_KN(momentum_, B_):
# momentum variable in [GeV], B field in [muG], => result in [GeV * s^{-1}]
    
    f_KN_times_U = 0.
    for i in range (len(T_ISRF)):

        f_KN_times_U_single = ( (factor_ratio * ( m_e / (k_boltzmann*T_ISRF[i]) )**2) / ( (factor_ratio * ( m_e / (k_boltzmann*T_ISRF[i]) )**2) + (momentum_/m_e)**2 ) ) * U_ISRF[i]
        #f_KN_times_U_single = U_ISRF[i]     # uncomment for the Thomson limit
        f_KN_times_U = f_KN_times_U + f_KN_times_U_single
        
    U_B = ( (B_*1.e-6)**2 / (8*np.pi) ) * conv_erg_GeV
    dp_dt_KN = - (4/3) * (sigma_Thomson * c_cm) * (f_KN_times_U + U_B) * (momentum_/m_e)**2
    return dp_dt_KN



## define the spatial-dependent magnetic field in the region
def B_field(x_):
    # result in [muG]
    return ( x_ / shock_location )**(-1.) * B_TS

B_space = np.zeros( len(x_grid) )
for ix in range(len(x_grid)):
    if x_grid[ix] <= (L_c/L_ref):
        B_space[ix] = B_field(x_grid[ np.argmin( abs(x_grid - L_c/L_ref) ) ])
    elif x_grid[ix] > (L_c/L_ref) and x_grid[ix] <= shock_location:
        B_space[ix] = B_field(x_grid[ix])
    else:
        B_space[ix] = B_field(shock_location) / np.sqrt(11)

B_field_indx_max = np.argmax( B_space )


# momentum loss-rate in each location
loss_rate_KN_matrix = np.zeros( (len(x_grid), len(p_grid)) )
for ix in range(len(x_grid)):
    for ip in range(len(p_grid)):
        
        loss_rate_KN_matrix[ix, ip] = loss_rate_KN(p_grid[ip], B_space[ix])

        
        
# Hadrons
def loss_rate_pp_collisions(indx_r_, momentum_):
# momentum variable in [GeV], result in [GeV * s^{-1}]

    L_log = np.log(momentum_ / 1.e3)
    K_pi = 0.13
    return -5.1e-15 * K_pi * n_bubble_array[indx_r_] * (momentum_ / 1.) * (1 + 5.5e-2 * L_log + 7.3e-3 * L_log**2)
    
loss_rate_pp_collision_matrix = np.zeros( (len(x_grid), len(p_grid)) )
for ix in range(len(x_grid)):
    loss_rate_pp_collision_matrix[ix, :] = [loss_rate_pp_collisions(ix, p_grid[ip]) for ip in range(len(p_grid))]


    

plt.figure(figsize=(13, 4.5))

plt.subplot(1, 2, 1)
plot_cosmetics_multi()


plt.loglog(p_grid, np.min(abs(loss_rate_KN(p_grid, B_space[shock_index]))) * (p_grid / min(p_grid))**2, lw=2.5, color='blue', label='$\propto p^2$ loss rate')
plt.loglog(p_grid, abs(loss_rate_KN(p_grid, B_space[shock_index])), lw=2.5, color='red', label='$\\approx$ Klein-Nishina')
plt.xlabel('$ p \, [\mathrm{GeV}/c]$',fontsize=20)
plt.ylabel('$ |\dot{p}| \, [\mathrm{GeV} \cdot \mathrm{s}^{-1}]$',fontsize=20)
plt.text(0.65, 0.1, '$B = \,$' + str("{:.1f}".format(B_space[shock_index])) + '$\, \mu \mathrm{G}$', fontsize=18, transform = plt.gca().transAxes)
plt.legend(fontsize=18, frameon=False)



# same but with dimensionless quantities
plt.subplot(1, 2, 2)
plot_cosmetics_multi()


plt.loglog(p_grid, np.min(abs((loss_rate_KN(p_grid, B_space[shock_index]) / pdot_ref))) * (p_grid / min(p_grid))**2, lw=2.5, color='blue', label='$\propto p^2$ loss rate')
plt.loglog(p_grid, abs((loss_rate_KN(p_grid, B_space[shock_index]) / pdot_ref)), lw=2.5, color='red', label='$\\approx$ Klein-Nishina')
plt.xlabel('$ p \, [\mathrm{GeV}/c]$',fontsize=20)
plt.ylabel('$ |\dot{p}| \\big/ \dot{p}_{\mathrm{ref}}$',fontsize=20)
plt.legend(fontsize=18, frameon=False)
plt.text(0.65, 0.25, '$B = \,$' + str("{:.1f}".format(B_space[shock_index])) + '$\, \mu \mathrm{G}$', fontsize=18, transform = plt.gca().transAxes)
plt.text(0.35, 0.1, '$\\dot{p}_{\mathrm{ref}} = \,$' + str('{:.2e}'.format(pdot_ref)) + ' $\mathrm{GeV} \cdot \mathrm{s}^{-1}$ ', fontsize=18, transform = plt.gca().transAxes)
plt.tight_layout()



# compute the diffusive distance after energy losses #
# leptons
def tau_func_KN(p_, B_):
    return - 1. / abs(loss_rate_KN(p_, B_))

def tau_func_Th(p_, B_):
    return - 1. / ( np.min(abs(loss_rate_KN(p_, B_))) * (p_ / min(p_grid))**2 )

# hadrons
def tau_pp_coll(indx_r_, momentum_):
    return - 1. / abs( loss_rate_pp_collisions(indx_r_, momentum_) )




## example, for a given magnetic field ##
momentum_ref_loss = 1.e+2      # in [GeV]
momentum_ref_loss_ind = np.argmin(abs(p_grid - momentum_ref_loss))
space_point_diff = 0

B_field = B_space[shock_index]         # magnetic field, in [muG]
U_B = ( (B_field*1.e-6)**2 / (8*np.pi) ) * conv_erg_GeV

list_integral_tau_KN = np.logspace(start=np.log10(momentum_ref_loss*10000), stop=np.log10(momentum_ref_loss), num=1000)
integral_tau_KN = np.trapz(tau_func_KN(list_integral_tau_KN, B_space[shock_index]), list_integral_tau_KN, axis=-1)   # in [sec]
diff_distance = np.sqrt( 4 * D_matrix[space_point_diff, momentum_ref_loss_ind] * integral_tau_KN ) * conv_cm_pc


print('** Example **')
print('')
print('B field =', B_field, '[muG], magnetic energy density =', U_B, '[GeV cm^{-3}]')
print('')
print('E*tau at', momentum_ref_loss, '[GeV/c]:', momentum_ref_loss * integral_tau_KN*conv_sec_yr/1.e6, '[GeV/c Myr]')
print('Loss timescale =', integral_tau_KN, '[s] =', integral_tau_KN*conv_sec_yr/1.e6, '[Myr]')
print('Diffusive distance for ' + str(momentum_ref_loss) + ' [GeV] leptons =', diff_distance, '[pc]')
print('')
#########################################


integrals_losses_KN = np.zeros(len(p_grid), dtype=np.float64)
integrals_losses_Th = np.zeros(len(p_grid), dtype=np.float64)
integrals_losses_ppcoll = np.zeros( (len(x_grid), len(p_grid)) )
for ip in range(len(p_grid)):
    # leptons
    list_integral_tau_KN_temp = np.logspace(start=np.log10(p_grid[ip]*10000), stop=np.log10(p_grid[ip]), num=1000)
    integrals_losses_KN[ip] = np.trapz(tau_func_KN(list_integral_tau_KN_temp, B_space[shock_index]), list_integral_tau_KN_temp, axis=-1)
    
    # hadrons
    list_integral_tau_ppcoll = np.logspace(start=np.log10(p_grid[ip]*10000), stop=np.log10(p_grid[ip]), num=1000)
    integrals_losses_ppcoll[:, ip] = [np.trapz(tau_pp_coll( ix, list_integral_tau_ppcoll ), list_integral_tau_ppcoll, axis=-1) for ix in range(len(x_grid))]

    

# definition of the timescales #
# leptons
timescale_losses = integrals_losses_KN*conv_sec_yr/1.e+6
timescale_diff = (L_ref*conv_pc_cm)**2 / (2.* D_matrix[shock_index, :])*conv_sec_yr/1.e+6
timescale_adv = [1./3. * (L_ref*conv_pc_cm) / (v_0_cm / compr_factor) * (L_ref / R_TS) * (1 - (R_TS / L_ref)**3.)*conv_sec_yr/1.e+6 for i in range(len(p_grid))]
timescale_acc_sec = (3. / (v_0_cm - v_0_cm/compr_factor) * ( (D_matrix[0, :] / v_0_cm) + (D_matrix[0, :] / (v_0_cm/compr_factor)) ))
timescale_acc = timescale_acc_sec * conv_sec_yr/1.e6
# hadrons
timescale_pp_losses = integrals_losses_ppcoll*conv_sec_yr/1.e+6

# leptons
indx_intersec_LossDiff = np.argmin( abs(timescale_losses - timescale_diff) )
indx_intersec_LossAdv = np.argmin( abs(timescale_losses - timescale_adv) )
indx_intersec_LossAcc = np.argmin( abs(timescale_losses - timescale_acc) )
# hadrons
indx_intersec_ppLossAcc = np.zeros( len(x_grid) )
indx_intersec_ppLossAcc = [np.argmin( abs(timescale_pp_losses[ix] - timescale_acc) ) for ix in range(len(x_grid))]
##########################



plt.figure(figsize=(13, 5.))

plt.subplot(1, 2, 1)
plot_cosmetics_multi()

plt.title('Leptons', fontsize=18, pad=8)
plt.loglog(p_grid, timescale_losses, lw=2., color='red', label='$\\approx$ Klein-Nishina, $B = \,$' + str("{:.1f}".format(B_space[shock_index])) + '$\, \mu \mathrm{G}$')
plt.loglog(p_grid, timescale_diff, lw=2., color='blue', label='$\\tau_{\mathrm{diff}} = \\frac{L^2_{\mathrm{ref}}}{2 \cdot D(p)}, \; \\delta = \,$' + str(delta_diff))
plt.loglog(p_grid, timescale_adv, lw=2., color='green', label='$\\tau_{\mathrm{adv}} = \\int^{R_{\mathrm{b}}}_{R_{\mathrm{TS}}} \\frac{dr}{v_{\mathrm{d}}(r)}, \; v_{\mathrm{d}} = \,$'+ str("${}$".format(f.format_data(v_0/compr_factor))) + '$\, \mathrm{km \cdot s^{-1}}$')
plt.loglog(p_grid, timescale_acc, lw=2., color='orange', label='$\\tau_{\mathrm{acc}}$')
plt.xlabel('$ p \, [\mathrm{GeV}/c]$',fontsize=20)
plt.ylabel('$\\tau \, [\mathrm{Myr}]$',fontsize=20)
plt.legend(fontsize=15, frameon=False)


plt.subplot(1, 2, 2)
plot_cosmetics_multi()

pp_coll_loss_indx = shock_index
plt.title('Protons', fontsize=18, pad=8)
plt.loglog(p_grid, timescale_pp_losses[pp_coll_loss_indx,:], lw=2., color='red', label='$\\tau_{pp}, \, n_{\mathrm{bubble}} = \,$' + str("{:.1f}".format(n_bubble_array[pp_coll_loss_indx])) + '$\, \mathrm{cm^{-3}}$')
plt.loglog(p_grid, timescale_diff, lw=2., color='blue', label='$\\tau_{\mathrm{diff}} = \\frac{L^2_{\mathrm{ref}}}{2 \cdot D(p)}, \; \\delta = \,$' + str(delta_diff))
plt.loglog(p_grid, timescale_adv, lw=2., color='green', label='$\\tau_{\mathrm{adv}} = \\int^{R_{\mathrm{b}}}_{R_{\mathrm{TS}}} \\frac{dr}{v_{\mathrm{d}}(r)}, \; v_{\mathrm{d}} = \,$'+ str("${}$".format(f.format_data(v_0/compr_factor))) + '$\, \mathrm{km \cdot s^{-1}}$')
plt.loglog(p_grid, timescale_acc, lw=2., color='orange', label='$\\tau_{\mathrm{acc}}$')
plt.xlabel('$ p \, [\mathrm{GeV}/c]$',fontsize=20)
plt.ylabel('$\\tau \, [\mathrm{Myr}]$',fontsize=20)
plt.legend(fontsize=15, frameon=False)

plt.tight_layout()
plt.savefig(dirName + 'Timescales.pdf',format='pdf',bbox_inches='tight', dpi=200)